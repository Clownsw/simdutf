from sse_validate_utf16le_proof import all_sequences, mask
from random import randint


def generate_valid():
    if randint(0, 1) == 0:
        return randint(0x0000, 0xd7ff)
    else:
        return randint(0xe000, 0xffff)


def generate_low_surrogate():
    return randint(0xd800, 0xdbff)


def generate_high_surrogate():
    return randint(0xdc00, 0xdfff)


CPP = """// generated by scripts/sse_validate_utf16le_testcases.py
struct ValidateUTF16Testcase {
    uint16_t values[8];
    char valid;
};

static uint16_t V = 0x%(V)04x;
static uint16_t L = 0x%(L)04x;
static uint16_t H = 0x%(H)04x;

const int validate_utf16_testcase_size = %(count)d;
const ValidateUTF16Testcase validate_utf16_testcase[%(count)d] = {
%(records)s
};
"""

class Record:
    def __init__(self):
        self.words = []
        self.pad_value = generate_valid()


    def add(self, word):
        self.words.append(word)


    @property
    def is_valid(self):
        c = mask(self.words)

        if c == 0xffff:
          return True

        if c == 0x7fff:
          # in test we reject cases when 'L' or 'H' ends a chunk
          if self.words[-1] in ('L', 'H'):
            return False
          else:
            return True

        return False


    def __str__(self):
        words = ','.join(self.words)
        return f'{{{{{words}}}, {int(self.is_valid)}}}'


def make_cpp_file(file):
    case_number = False
    records = []
    for words in all_sequences():
        record = Record()
        for word in words:
            record.add(word)

        if case_number:
            records.append(f'/* {len(records)} */ ' + str(record))
        else:
            records.append(str(record))

    file.write(CPP % {
        'V': generate_valid(),
        'L': generate_low_surrogate(),
        'H': generate_high_surrogate(),
        'count': len(records),
        'records': ',\n'.join(records)
    })


def main():
    with open('validate_utf16_testcases.inl', 'w') as f:
        make_cpp_file(f)


if __name__ == '__main__':
    main()
